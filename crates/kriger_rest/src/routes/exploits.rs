// SPDX-License-Identifier: AGPL-3.0-only
// Copyright Authors of kriger

use crate::support::{AppError, AppJson};
use crate::AppState;
use axum::extract::Path;
use axum::response::IntoResponse;
use axum::{extract::State, Json};
use kriger_common::messaging::Bucket;
use kriger_common::{messaging, models};
use std::sync::Arc;

pub(crate) async fn get_exploits(
    state: State<Arc<AppState>>,
) -> Result<impl IntoResponse, AppError> {
    let exploits_bucket = state.runtime.messaging.exploits();
    let exploits: Vec<models::Exploit> = exploits_bucket.list(None).await?.into_values().collect();

    Ok(Json(models::responses::AppResponse::Ok(exploits)))
}

pub(crate) async fn update_exploit(
    state: State<Arc<AppState>>,
    Path(name): Path<String>,
    AppJson(exploit): AppJson<models::Exploit>,
) -> Result<impl IntoResponse, AppError> {
    if name != exploit.manifest.name {
        return Err(AppError::BadInput(
            "the exploit manifest does not match the provided exploit name",
        ));
    }

    // TODO: Validate the exploit manifest thoroughly before completing the request
    let exploits_bucket = state.runtime.messaging.exploits();

    exploits_bucket
        .put(&exploit.manifest.name, &exploit)
        .await?;

    Ok(Json(models::responses::AppResponse::Ok(())))
}

pub(crate) async fn execute_exploit(
    state: State<Arc<AppState>>,
    Path(name): Path<String>,
) -> Result<impl IntoResponse, AppError> {
    let scheduling_svc = state.runtime.messaging.scheduling();

    scheduling_svc
        .publish_request(&messaging::model::SchedulingRequest { exploit: name })
        .await?;

    Ok(Json(models::responses::AppResponse::Ok(())))
}
