use axum::extract::Path;
use axum::response::IntoResponse;
use axum::{extract::State, Json};
use kriger_common::messaging::{model::Exploit, Bucket, Messaging};
use std::sync::Arc;

use crate::support::{AppError, AppJson, AppResponse};
use crate::AppState;

pub(crate) async fn update_exploit(
    state: State<Arc<AppState>>,
    Path(name): Path<String>,
    AppJson(exploit): AppJson<Exploit>,
) -> Result<impl IntoResponse, AppError> {
    if name != exploit.manifest.name {
        return Err(AppError::BadInput(
            "the exploit manifest does not match the provided exploit name",
        ));
    }

    let exploits_bucket = state.runtime.messaging.exploits().await?;

    exploits_bucket
        .put(&exploit.manifest.name, &exploit)
        .await?;

    Ok(Json(AppResponse::Ok(())))
}
