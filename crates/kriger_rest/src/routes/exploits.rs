use crate::support::{AppError, AppJson};
use crate::AppState;
use axum::extract::Path;
use axum::response::IntoResponse;
use axum::{extract::State, Json};
use kriger_common::messaging::{Bucket, Messaging};
use kriger_common::models;
use std::sync::Arc;

pub(crate) async fn get_exploits(
    state: State<Arc<AppState>>,
) -> Result<impl IntoResponse, AppError> {
    let exploits_bucket = state.runtime.messaging.exploits().await?;
    let exploits: Vec<models::Exploit> = exploits_bucket.list(None).await?.into_values().collect();

    Ok(Json(models::responses::AppResponse::Ok(exploits)))
}

pub(crate) async fn update_exploit(
    state: State<Arc<AppState>>,
    Path(name): Path<String>,
    AppJson(exploit): AppJson<models::Exploit>,
) -> Result<impl IntoResponse, AppError> {
    if name != exploit.manifest.name {
        return Err(AppError::BadInput(
            "the exploit manifest does not match the provided exploit name",
        ));
    }

    let exploits_bucket = state.runtime.messaging.exploits().await?;

    exploits_bucket
        .put(&exploit.manifest.name, &exploit)
        .await?;

    Ok(Json(models::responses::AppResponse::Ok(())))
}
