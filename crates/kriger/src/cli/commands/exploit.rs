use crate::cli::commands::acquire_exploit_manifest;
use crate::cli::models::CliConfig;
use crate::cli::{args, read_cli_config};
use color_eyre::eyre;
use console::style;
use kriger_common::client::KrigerClient;
use kriger_common::models;
use std::collections::btree_map::Entry;
use std::collections::BTreeMap;

pub(crate) async fn main(args: args::ExploitCommand) -> eyre::Result<()> {
    let cli_config = read_cli_config().await?;

    match args {
        args::ExploitCommand::Hints(inner) => hints(cli_config, inner).await?,
    }

    Ok(())
}

async fn hints(cli_config: CliConfig, _args: args::ExploitHints) -> eyre::Result<()> {
    let cli_manifest = match acquire_exploit_manifest().await {
        Some(manifest) => manifest,
        None => return Ok(()),
    };

    let client = KrigerClient::new(cli_config.client.rest_url);
    let res = client
        .get_competition_flag_hints(cli_manifest.exploit.service)
        .await?;

    match res {
        models::responses::AppResponse::Ok(hints) => {
            let mut map: BTreeMap<String, Vec<String>> = BTreeMap::new();
            for hint in hints {
                let entry = match map.entry(hint.team_id) {
                    Entry::Occupied(entry) => entry.into_mut(),
                    Entry::Vacant(a) => a.insert(Vec::new()),
                };
                let content =
                    serde_json::to_string(&hint.hint).unwrap_or_else(|error| error.to_string());
                entry.push(content);
            }

            for (team_id, hints) in map {
                println!("{}", style(format!("Team {team_id}")).bold());
                for hint in hints {
                    println!(" {} {}", style("-").blue(), hint);
                }
            }
        }
        models::responses::AppResponse::Error { message } => {
            eprintln!("{}", message);
        }
    }

    Ok(())
}
