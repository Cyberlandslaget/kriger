// SPDX-License-Identifier: AGPL-3.0-only
// Copyright Authors of kriger

use crate::cli::commands::acquire_exploit_manifest;
use crate::cli::models::CliConfig;
use crate::cli::{args, emoji, format_duration_secs, read_cli_config};
use color_eyre::eyre;
use color_eyre::eyre::{bail, Context, ContextCompat};
use console::style;
use kriger_common::client::KrigerClient;
use kriger_common::models;
use kriger_runner::runner::simple::SimpleRunner;
use kriger_runner::runner::{Runner, RunnerEvent, RunnerExecution};
use regex::Regex;
use std::collections::btree_map::Entry;
use std::collections::{BTreeMap, HashMap};
use std::time::Duration;
use tokio::join;

pub(crate) async fn main(args: args::ExploitCommand) -> eyre::Result<()> {
    let cli_config = read_cli_config().await?;

    match args {
        args::ExploitCommand::Hints(inner) => hints(cli_config, inner).await?,
        #[cfg(feature = "runner")]
        args::ExploitCommand::Dev(inner) => dev(cli_config, inner).await?,
    }

    Ok(())
}

async fn hints(cli_config: CliConfig, _args: args::ExploitHints) -> eyre::Result<()> {
    let cli_manifest = match acquire_exploit_manifest().await {
        Some(manifest) => manifest,
        None => return Ok(()),
    };

    let client = KrigerClient::new(cli_config.client.rest_url);

    // TODO: Parallelize and properly handle errors
    let hints_res = client
        .get_competition_flag_hints(cli_manifest.exploit.service.clone())
        .await?;
    let teams = match client.get_competition_teams().await? {
        models::responses::AppResponse::Ok(team_map) => team_map,
        models::responses::AppResponse::Error { .. } => HashMap::new(),
    };

    match hints_res {
        models::responses::AppResponse::Ok(hints) => {
            let mut map: BTreeMap<String, Vec<String>> = BTreeMap::new();
            for hint in hints {
                let entry = match map.entry(hint.team_id) {
                    Entry::Occupied(entry) => entry.into_mut(),
                    Entry::Vacant(a) => a.insert(Vec::new()),
                };
                let content =
                    serde_json::to_string(&hint.hint).unwrap_or_else(|error| error.to_string());
                entry.push(content);
            }

            for (team_id, hints) in map {
                let ip_address = match teams.get(&team_id) {
                    Some(team) => match team.services.get(&cli_manifest.exploit.service) {
                        // The service has a service-specific IP address
                        Some(addr) => Some(addr),
                        None => team.ip_address.as_ref(),
                    },
                    None => None,
                };
                match ip_address {
                    Some(addr) => {
                        println!(
                            "{} ({})",
                            style(format!("Team {team_id}")).bold(),
                            style(addr).yellow()
                        );
                    }
                    None => {
                        println!("{}", style(format!("Team {team_id}")).bold());
                    }
                }
                for hint in hints {
                    println!(" {} {}", style("-").blue(), hint);
                }
            }
        }
        models::responses::AppResponse::Error { message } => {
            eprintln!("{}", message);
        }
    }

    Ok(())
}

#[cfg(feature = "runner")]
async fn dev(cli_config: CliConfig, args: args::ExploitDev) -> eyre::Result<()> {
    let cli_manifest = match acquire_exploit_manifest().await {
        Some(manifest) => manifest,
        None => return Ok(()),
    };

    let client = KrigerClient::new(cli_config.client.rest_url);

    // TODO: Parallelize and properly handle errors
    let server_config = match client.get_server_config().await? {
        models::responses::AppResponse::Ok(team_map) => team_map,
        models::responses::AppResponse::Error { message } => bail!(message),
    };
    let hints_res = client
        .get_competition_flag_hints(cli_manifest.exploit.service.clone())
        .await?;
    let hints = match hints_res {
        models::responses::AppResponse::Ok(hints) => hints,
        models::responses::AppResponse::Error { message } => bail!(message),
    };
    let teams = match client.get_competition_teams().await? {
        models::responses::AppResponse::Ok(team_map) => team_map,
        models::responses::AppResponse::Error { message } => bail!(message),
    };
    let team_id = match args.team_id {
        Some(team_id) => Some(team_id),
        None => server_config.competition.nop_team,
    }
    .context("unable to automatically determine the target team")?;

    let hint = hints
        .into_iter()
        .filter(|hint| hint.team_id == team_id)
        .last()
        .map(|hint| hint.hint);
    let team = match teams.get(&team_id) {
        Some(team) => team,
        None => {
            eprintln!("hint not found");
            return Ok(());
        }
    };
    let ip_address = match team.services.get(&cli_manifest.exploit.service) {
        // The service has a service-specific IP address
        Some(addr) => Some(addr),
        None => team.ip_address.as_ref(),
    };
    let ip_address = match ip_address {
        Some(addr) => addr,
        None => {
            eprintln!("ip address not found");
            return Ok(());
        }
    };

    let flag_format =
        Regex::new(&server_config.competition.flag_format).context("invalid regex")?;

    println!(
        "Team: {} {}",
        style(team_id).blue(),
        style(format!("({ip_address})")).dim()
    );
    let flag_hint_display = match &hint {
        Some(value) => serde_json::to_string(&value)
            .ok()
            .unwrap_or("invalid hint".to_string()),
        None => "none".to_string(),
    };
    println!("Flag hint: {}", style(flag_hint_display).blue());
    println!();

    let runner = SimpleRunner {
        exploit_name: cli_manifest.exploit.name,
        // TODO: Extract the command from the Dockerfile somehow
        exploit_command: "python3".to_string(),
        exploit_args: vec!["exploit.py".to_string()],
        timeout: Duration::from_secs(cli_manifest.exploit.resources.timeout as u64),
        flag_format,
    };

    let execution = runner
        .run(ip_address, &hint)
        .await
        .context("runner error")?;

    let (_, result) = join!(handle_dev_events(execution.events()), execution.complete());

    println!();
    if let Some(exit_code) = result.exit_code {
        println!(
            "{} {} {} {} {}",
            emoji::CHEQUERED_FLAG,
            style("Execution completed in").green().bold(),
            style(format_duration_secs(&result.time)).blue().bold(),
            style("with exit code").green().bold(),
            style(exit_code).yellow().bold()
        );
    } else {
        println!(
            "{} Execution completed in {}",
            emoji::CHEQUERED_FLAG,
            style(format_duration_secs(&result.time)).blue(),
        );
    }

    Ok(())
}

async fn handle_dev_events(events: flume::Receiver<RunnerEvent>) {
    while let Ok(event) = events.recv_async().await {
        match event {
            RunnerEvent::Stdout(line) => {
                println!("{line}");
            }
            RunnerEvent::Stderr(line) => {
                eprintln!("{line}");
            }
            RunnerEvent::FlagMatch(flag) => {
                println!(
                    "{} {} {}",
                    emoji::TRIANGULAR_FLAG,
                    style("Flag:").green().bold(),
                    flag
                )
            }
        }
    }
}
