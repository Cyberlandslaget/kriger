use crate::cli::commands::acquire_exploit_manifest;
use crate::cli::models::CliConfig;
use crate::cli::{args, read_cli_config};
use color_eyre::eyre;
use console::style;
use kriger_common::client::KrigerClient;
use kriger_common::models;
use std::collections::btree_map::Entry;
use std::collections::{BTreeMap, HashMap};

pub(crate) async fn main(args: args::ExploitCommand) -> eyre::Result<()> {
    let cli_config = read_cli_config().await?;

    match args {
        args::ExploitCommand::Hints(inner) => hints(cli_config, inner).await?,
    }

    Ok(())
}

async fn hints(cli_config: CliConfig, _args: args::ExploitHints) -> eyre::Result<()> {
    let cli_manifest = match acquire_exploit_manifest().await {
        Some(manifest) => manifest,
        None => return Ok(()),
    };

    let client = KrigerClient::new(cli_config.client.rest_url);

    // TODO: Parallelize and properly handle errors
    let hints_res = client
        .get_competition_flag_hints(cli_manifest.exploit.service.clone())
        .await?;
    let teams = match client.get_competition_teams().await? {
        models::responses::AppResponse::Ok(team_map) => team_map,
        models::responses::AppResponse::Error { .. } => HashMap::new(),
    };

    match hints_res {
        models::responses::AppResponse::Ok(hints) => {
            let mut map: BTreeMap<String, Vec<String>> = BTreeMap::new();
            for hint in hints {
                let entry = match map.entry(hint.team_id) {
                    Entry::Occupied(entry) => entry.into_mut(),
                    Entry::Vacant(a) => a.insert(Vec::new()),
                };
                let content =
                    serde_json::to_string(&hint.hint).unwrap_or_else(|error| error.to_string());
                entry.push(content);
            }

            for (team_id, hints) in map {
                let ip_address = match teams.get(&team_id) {
                    Some(team) => match team.services.get(&cli_manifest.exploit.service) {
                        // The service has a service-specific IP address
                        Some(addr) => Some(addr),
                        None => team.ip_address.as_ref(),
                    },
                    None => None,
                };
                match ip_address {
                    Some(addr) => {
                        println!(
                            "{} ({})",
                            style(format!("Team {team_id}")).bold(),
                            style(addr).yellow()
                        );
                    }
                    None => {
                        println!("{}", style(format!("Team {team_id}")).bold());
                    }
                }
                for hint in hints {
                    println!(" {} {}", style("-").blue(), hint);
                }
            }
        }
        models::responses::AppResponse::Error { message } => {
            eprintln!("{}", message);
        }
    }

    Ok(())
}
